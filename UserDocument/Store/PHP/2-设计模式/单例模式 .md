# 单例 
> 生成对象之单例

## 概念
生成一个且生成一个对象实例的特殊类

## 为什么要使用单例模式
- 替换全局变量：PHP中全局变量不受保护，而且出现冲突不会出现警告。如果系统中需要有一个类来全局控制某些配置信息, 那么使用单例模式可以很方便的实现. 该对象可以被系统中的任何对象使用。
- php的应用主要在于数据库应用, 所以一个应用中会存在大量的数据库操作, 使用单例模式, 则可以避免大量的new 操作消耗的资源。
- 在一次页面请求中, 便于进行调试, 因为所有的代码(例如数据库操作类db)都集中在一个类中, 我们可以在类中设置钩子, 输出日志，从而避免到处var_dump, echo。
- 
## 生成单例
单例需要满足如下几个要求：
-    必须拥有一个构造函数，并且必须被标记为private：私有的构造函数创建了一个无法从自身外部来创建实例的类。为了防止克隆克隆函数也必须声明为私有。
```
    private function __construct()   
    {   
        $this->_db = pg_connect('xxxx');  
    }   
    private function __clone()  
    {  
    }//覆盖__clone()方法，禁止克隆  
       
```

-    拥有一个保存类的实例的静态成员变量:因为没办法从外部实例化对象，因此使用静态属性或者方法来间接实例化对象。
```
private static $_instance; 
```

- 拥有一个访问这个实例的公共的静态方法,（通常为getInstance方法），从而返回唯一实例的一个引用。 
    - $_instance属性设置为static和private，因此不能在类外部被访问，而getInstance方法在类内部，所以可以访问$_instance属性。
    - getInstance方法是public和static的，所以可以在任何地方调用。
    - 静态方法getInstance为类的一部分，所以尽管构造函数是私有的，但实例化对象是没有问题的。
```
    public static function getInstance()    
    {    
        if(! (self::$_instance instanceof self) )   
        {    
            self::$_instance = new self();    
        }  
        return self::$_instance;    
    }   
```

## 缺点
单例对象的全局化性质会使程序员绕过类接口定义的通信线路，当单例被使用时，依赖便会隐藏在方法内部，而并不会出现在方法声明中，这使得系统中的以来关系更加难以追踪，因此需要更加小心谨慎的部署单类。

